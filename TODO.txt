TODO


improve mouseover state
	+ On Mar 2nd: "Note flickering of mouseover state on drag"
	
implement Action#draw
	actions should be able to render information,
	to show things like what axis scaling in occuring on,
	or other helpful visualizations
	
	they also should be able to change the cursor, but I'm not sure that belongs here
	as that is altering the state of the cursor, more than anything



using builder pattern, getting dependency list and interface name from the class is a bit obtuse
	consider moving at least the name into the instance level
	not like you're really spending that much extra memory anyway
	it's either just one symbol, or a pointer to some shared collection


BUG
	resizing text horizontally from center of right edge
	immediately after resizing from center of bottom edge
	results in text disappearing and program freezing
	
	not sure if this is a Gosu issue,
	an issue with limited system resources,
	or an issue with my code



May want to change how text resizes horizontally on center drag
	computes 'center' as the center of the vertical distance of the hitbox
	this is not the same as the 'center' of the text, which should be located at the midline




If Style is created without a parent, it's parent should default to the baseline style
	not sure where the baseline style should be declared,
	it should be a constant variable that can be easily accessed from everywhere
	it should declare all available properties




Make Camera only draw items from the space that it detects.
	Not sure if this should be a modification to the core camera,
	or if it should be some camera subclass.
	
	This is much better than the current structure of passing in things to render,
	and only using Camera for transform.
	
	This will allow for things like camera culling, which is nice.


Figure out how to change Entities when style properties are altered




edit space point query
should be able to get a list of things under the mouse
only highligh the one that the mouse will be working on
it seems weird that you would highlight something that you can't act on?
	that means that the selection has to change a little bit depending on what action is active
	is that too much state going into the selection?
	will that be the user's expected model of operation?






create action or something that allows for the movement of the Camera
	move action was not added to Camera explicitly under new structure
	because all of the "add_action" calls were removed
	
	really just a matter of creating a new action flow for
	when you know exactly what Entity you want, 
	and exactly what Action to fire on it
	
	and then hook that up to the input system


is there any reason to keep Component?
	it's this weird strict-typed flavor in a duck-typed system
	especially that Actions have been reworked to be more like methods,
	maybe components should just be like any other thing attached to a class?
	
	not really sure if there's any motivation to adhere strictly to entity/component style
	considering how in the current structure, methods are attached to the object,
	not to the components
	
	(or like, sometimes the action, but never the component)
	(meaning the structure is NOT actually entity/component at all)










TODO: implement screen space to world space conversion in accordance with new systems

old system had assumed that there was a global variable with a pointer to Window
trying to remove that
need to figure out how to perform coordinate space conversions in a sane manner now








TODO: consider using Class#inherited to assemble Action lists on Entity classes.
	(or at least like, cache them?)

actually, that could get really messy. it's probably better to just traverse the hierarchy

or maybe you want to figure out how Ruby as a language resolves methods?









TODO: custom subclass of Hash to deal with action bindings

need to make sure there's some sort of error when you try to declare inputs for phases that don't actually exist. otherwise, you can just go a bug hunt without knowing where the problem is.

need to find a balance between duck-typing-style dynamicism and strict protection











TODO: Ruby methods are objects. Apply structure to Action

methods in Ruby can be manipulated as objects, because everything is an object
how does this work?
how is it specifically implemented?


would this help implementation of the Action objects,
to help them function more like method calls?