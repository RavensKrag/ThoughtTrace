how to check for changes?

	constraint needs to know what values to be looking for
	it will be given Entity objects A and B
	and then it will note what properties are important from those elements
	the important values will be saved in a cache.
	When the cached values are different from the values for the current frame,
	then the constraint must be run.
	
	This cached state is kept separate from the constraint itself,
	so that one constraint object can be used in multiple places
	
	(((  think of it almost like a lambda, 
	     a pointer to an executable program-part that gets passed around  )))






how fast do changes propagate through the graph?

	should move at least across one edge per frame,
	but it's not super clear when things will get to their destination
	(it's rather like a distributed programming problem, in that way)

	there's no point in trying to make it so changes can propagate across the entire graph in one tick:
	that would just make it harder for the system to function in real time
	for large graphs






note that changes won't always propagate the same way
- dependent on graph topology and update order








multiple types of changes can propagate within the same tick,
but not all data will propagate to it's final destination in one tick.
sometimes, the system will need many ticks for data to traverse certain paths.
hopefully though, no data gets stuck in a node, unable to leave the edge, or anything like that
(current system does not prevent against deadlock / livelock)
(exercise caution when designing graph topologies)

I feel like data should probably at least leave it's original source within one tick in most situations...






***
	* you could maybe reduce the likelyhood of issues like clobbering, livelock / deadlock, etc by looking at the entire path through the graph, from the changed node to the 'leaves', and propagating that change all at once. you don't have to examine all constraints, just the ones of the same type.
		idk, that might actually be harder.
		I'll have to try it out though, because it might solve some problems.
		(but it might just cause a bunch of others)


---old notes ---
how do you create that and traverse it?
the core graph is user-generated
but then the sub-graph is also a graph
and it may have some cycles in it
you need to prevent execution of a multiple looping paths through the graph in one tick



maybe that's wrong, and it should be like an "everyone pass one to your right" per tick thing
meaning, that sometimes the simulation will take more ticks to propagate changes than others
---

^ note that this means any sort of 'linear-ization' of the graph will have to check for cycles


but the standard technique being applied going forward,
does not need to check for cycles
because it will only evaluate each edge once per tick







really only want to update each edge once per tick

	this means that some changes will take many ticks
	to propagate all the way to their destination,
	but it ensures that you will never get stuck
	in a situation where you have to traverse an
	entire loop of the graph
		(or multiple iterations of this loop, even)
	in one tick

	games have circular flow.
	if you want a 'loop'
	you often want one tick of the loop executed per game tick
	you very rarely want to use a straight 'while' loop in a game

	this system is a similar sort of thing


	note that 'one edge' in this case means
	one pair-wise relationship between two Entity objects
	related by one constraint.
	Thus, the same pair of Entities can be connected by multiple edges,
	even in the same direction,
	and having all of those update in the same frame is totally fine.

	But you don't want the same constraint firing
	between two Entity objects multiple times in one frame



	because that has the possibility of creating cycles,
	and that's really bad
	
	
	but note that this is different that firing a Constraint object once per tick,
	because one Constraint object can be used in the definition of multiple edge groups
	
	(note also that 'edge group' is used, rather than edge, because of the All enumerator)









one edge group has one of each of these:
* constraint object
* enumerator
* visualization object

the visualization has state,
	as it must flip between two draw modes, and render some things
the enumerator has state
	as it must keep track of the entities to iterate through
the constraint has NO STATE so it can be used across various edge groups

HOWEVER

the constraint can be parameterized
which is sorta form of state.
so it's more proper to say that a Constraint object hold no state pertaining to any one Entity,
or pair of Entity objects.














major different types of constraints

* propagating constraints
* limiting constraints

but these types are not formally declared through classes or anything
it's just important to know
that these seem to be the two main ways
that constraints are used and written


old notes on constraint types
	limit height
		constraint needs to be updated whenever B changes
		to make sure that B's height has not exceeded the limit prescribed by A


	sync height
		update when A changes
		to make sure that the changes from A propagate to B




	it may be accurate to say that constraints are always defined as binary operations,
	but some allow for propagation of new data,              (propagating constraint)
	while some constrain the expansion of existing data      (limiting constraint)


	perhaps more properly, 
	these two things are both categories of "relationships"
	with the latter being a constraint,
	and the former requiring some other name
	(maybe a 'driver'?)
	driver, mover, inducer, conductor




	propagating constraints do still constraint the output value though
	so maybe 'constraint' is still a good name?
	(IKs limit where the extremities can be placed, by indirectly controlling their placement)
	(copying a value from A to B certainly does limit what values B can have)









	some double relations are even
	the same relationship in both directions      (truly can be condensed into a double-headed arrow)
	but some pairs have uneven relationships
	like a parent and child, or student and teacher
	data goes back and forth, but not the same sort of data












optimizations?

flattening method chains?

	flatten the method chains?
	then you can get callbacks for when data is updated
	and propagate changes based on that


	but that doesn't work if the physics space needs to update things
	basically, you would need to be able to control all changes to the data to guarantee this update system







cycles / circular dependencies
race conditions

	these things are important to prevent
	but the system will not actively prevent you from making graphs that have these properties
	
	the exact time when some data gets to it's final destination
	is a property of the graph topology.
	In some cases, the data may never reach it's intended final destination,
		because there has been some sort of clobbering due to graph topology.
	In others, you may have things flip between a couple different states, but never settle down.
	
	It's basically too hard at this point to completely prevent these problems.
	It's hard to see these problems in standard text-editor code,
	which is part of why I wanted to make this system.
	I hope that in the future, some graph-level systems can be ported down to text-code for efficient prevention of common mistakes.






