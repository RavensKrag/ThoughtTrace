What are constraints?

	Constraints are relationships between two Entities.
	
	They are essentially defined as pairwise functions,
	( but the reality is a bit more complicated than that ).
	
	Hopefully this document will fully explain.





General reminders: ( come back and read this later )
	constraint logic for how to apply the constraint tick is separate from
	when to apply the tick
	the latter is really dependent on specifics
	and includes whether or not you need a "dirty flag" or cache or whatever
	and the cache isn't reusable between pairs
	but the rest of the parameterized constraint is
	so that's yet another reason to keep things separate






when are constraints triggered?
	
	Constraints will only fire when data in the dependent Entity objects have been _changed_
	( sometimes you have to check one entity, sometimes you have to check both )






how to check for changes?

	constraint needs to know what values to be looking for
	
	it will be given Entity objects A and B
	and then it will note what properties are important from those elements
	( this code is declared in Constraint#foo()     [which really needs a better name btw] )
	
	the important values will be saved in a cache.
	When the cached values are different from the values for the current frame,
	then the constraint must be run.
	
	This cached state is kept separate from the constraint itself,
	so that one constraint object can be used in multiple places
	
	(((  think of the constraint object like a lambda, 
	     a pointer to an executable program-part that gets passed around  )))






how fast do changes propagate through the graph?

	should move at least across one edge per frame,
	but it's not super clear when things will get to their destination
	(it's rather like a distributed programming problem, in that way)

	there's no point in trying to make it
	so changes can propagate across the entire graph in one tick:
		that would just make it harder for the system to function in real time
		for large graphs
	
	
	
	(NOTE: this is not totally accurate. you just have to make sure you don't traverse too many long paths. ("long" being relative to N, where N is the number of active constraint pairs). However, the current implementation tries to keep things simple by only updating each constraint pair once per tick. This ensures no loops or combinatorial explosion, but may cause other errors.)






note that changes won't always propagate the same way
- dependent on graph topology and update order






multiple types of changes can propagate within the same tick,
but not all data will propagate to it's final destination in one tick.
sometimes, the system will need many ticks for data to traverse certain paths.
hopefully though, no data gets stuck in a node, unable to leave the edge, or anything like that
(current system does not prevent against deadlock / livelock)
(exercise caution when designing graph topologies)

I feel like data should probably at least leave it's original source within one tick in most situations...






***
	* you could maybe reduce the likelyhood of issues like clobbering, livelock / deadlock, etc by looking at the entire path through the graph, from the changed node to the 'leaves', and propagating that change all at once. you don't have to examine all constraints, just the ones of the same type.
		idk, that might actually be harder.
		I'll have to try it out though, because it might solve some problems.
		(but it might just cause a bunch of others)


---old notes ---
how do you create that and traverse it?
the core graph is user-generated
but then the sub-graph is also a graph
and it may have some cycles in it
you need to prevent execution of a multiple looping paths through the graph in one tick



maybe that's wrong, and it should be like an "everyone pass one to your right" per tick thing
meaning, that sometimes the simulation will take more ticks to propagate changes than others
---

^ note that this means any sort of 'linear-ization' of the graph will have to check for cycles


but the standard technique being applied going forward,
does not need to check for cycles
because it will only evaluate each edge once per tick







really only want to update each edge once per tick

	this means that some changes will take many ticks
	to propagate all the way to their destination,
	but it ensures that you will never get stuck
	in a situation where you have to traverse an
	entire loop of the graph
		(or multiple iterations of this loop, even)
	in one tick

	games have circular flow.
	if you want a 'loop'
	you often want one tick of the loop executed per game tick
	you very rarely want to use a straight 'while' loop in a game

	this system is a similar sort of thing


	note that 'one edge' in this case means
	one pair-wise relationship between two Entity objects
	related by one constraint.
	Thus, the same pair of Entities can be connected by multiple edges,
	even in the same direction,
	and having all of those update in the same frame is totally fine.

	But you don't want the same constraint firing
	between two Entity objects multiple times in one frame



	because that has the possibility of creating cycles,
	and that's really bad
	
	
	but note that this is different that firing a Constraint object once per tick,
	because one Constraint object can be used in the definition of multiple edge groups
	
	(note also that 'edge group' is used, rather than edge, because of the All enumerator)







Edge groups

	one edge group has one of each of these:
	* constraint object
	* enumerator
	* visualization object

	the visualization has state,
		as it must flip between two draw modes, and render some things
	the enumerator has state
		as it must keep track of the entities to iterate through
	the constraint has NO STATE so it can be used across various edge groups

	HOWEVER

	The constraint can be parameterized
	which is actually sort of a form of state.
	So it's more proper to say that a Constraint object hold no state pertaining to any one Entity,
	or pair of Entity objects.







major different types of constraints

	* propagating constraints   ...   move data from A to B
	* limiting constraints      ...   limit the expansion of values in B, according to values in A
	
	but these types are not formally declared through classes or anything
	it's just important to know
	that these seem to be the two main ways
	that constraints are used and written
	



examples of different types of constraints

	sync height                  (propagating constraint)
		update when A changes
		to make sure that the changes from A propagate to B
	
	
	limit height                 (limiting constraint)
		constraint needs to be updated whenever B changes
		to make sure that B's height has not exceeded the limit prescribed by A


defining constraints
	
	constraints are always defined as pairwise operations
	
	in mathematics, there are three types of operations:
		* unary
		* binary
		* n-ary

	but unary _constraints_ can not exist,
	because there must always be a hidden parameter,
	and that parameter should always just be an Entity
	
	Binary operations are easy to define in code,
	as you always know that the function will take two arguments.
	That's not very many arguments, and keeps things simple.

	In mathematics, n-ary operations are always defined as 2-ary (binary) operations,
	which should guarantee that all n-way constraints can be defined as binary relationships.
	
	
	QED: constraints are always defined pairwise
	
	(for elaboration of this train of thought, see 'evolution_of_the_system.txt')







Parameterization of Constraints
	
	Each Constraint object has a parameterizing closure inside of it.
	This parameterizing closure allows for certain variables within the constraint to be exposed to the graph editor, allowing editing of variables without needing to dig into code.
	
	This prevents the need to create additional classes all over the place that are really the exact same code, with the only difference being minor changes in some variable.
	
	
	
	ex) limit_height(0.8h) vs limit_height(0.3h)
	    ( this is not the actual parameterization syntax, but should help explain the concept )
	
	
	Every Constraint object (and thus all objects of child classes)
	will have a closure assigned to it,
	but some Constraints may elect to not pass data through the closure.
	
	Potentially, the constraint could be optimized out of elements that do not use it.
	( but maybe not? maybe memory alignment is more of a priority )
	
	
	
	currently, the "parameterizing closure" class is called Constraint::Closure




Serialization of Parameterized Constraint Objects
		
	Parameters will retain their values from previous sessions,
	regardless of if they are changed in the GUI, by a constraint in the graph,
	or by some other code.
	
	
	If new variables have been added to a Constraint,
	(ie the constraint definition has been updated)
	the default values for those variables will be assigned
	the next time that constraint is loaded.
	
	However, changing the default values in code will not effect values that have already been set.
		
		(  this would be a nice feature to have, because it allows for a live-coding-style environment, but it would be hard and weird to implement, so it will be skipped. at least for now. Priority is on making it able to abstract code, and allow for the graph to control aspects of the code. Making code edit the graph in a "live" manner is not a priority.  )
	
	
	Serialization of parameterized constraint objects is handled by ResourceCollection,
	the class which maintains those objects









Duplication of Constraints
	
	pointer to constraint, or deep copy, never shallow
	
	
	never going to use the same parameterization object
	for two separate constraint objects

	would always just use the same constraint object
	in two places instead
	
	






Constraint Markers
	Parameterized constraint objects will be bound to Entities using Markers.
	A Package will hold two markers, and the constraint associated with that pair.
	(Packages are fully explained in a later section)
	
	The use of Markers allows for the Constraint to be rebound to a new pair of Entities in the GUI
	simply by dragging a Marker over to a new Entity.
	
	
	
	Each Marker specifies two targets:
	+ render target
	+ constraint target
	
	Sometimes the render target will point to the target entity,
	sometimes it will point to the Marker itself,
	but a Marker will always have a render target.
		This way, the constraint can be made visible in the graph as long as it is allocated,
		even if it is not currently running.
	
	However, the constraint will only attempt to fire
	when both constraint targets have been bound.
	(recall that actually firing depends on other things as well, like passing cache test)
	
	
	
	
	NOTE:
	because Entity makes heavy use of method chaining,
	you can't use a null Entity to temporarily absorb the commands of an Constraint
	when the Constraint does not have a proper target. 
	(it's not one simple message that can be intercepted / stubbed)
	
	Thus, this two-target structure is used instead.







Binding Markers to Target Entities (bind to constraint target)
	NOTE: need to also consider how this system intersects with snapping the markers into certain positions
	
	
	
	
	
	
	bind marker on move action, not on collision
	
	otherwise, when things start to be moved around systemically, things could rebind
	which would be a cool systemic behavior...
	but also totally not what you want or expect
	
	if you really wanted that, you should be using query-bound constraints instead
	
	
	but you need to disambiguate which Entity is the desired target
	
	Currently using point_query_best, which is literally the same code for click selection,
	so the system will select the same object that would be selected by clicking,
	which should be rather intuitive.
	
	
	If there are no viable targets,
	the constraint target on the Marker will be unbound,
	and the Package will prevent the constraint from firing.
	
	
	
	
	
	the actual bind command will be declared on the Marker,
	so that the abstraction of the Action can be bypassed when binding in code.
	
	BUT WAIT
	you still need to move the markers into place so that further edits can happen in the graph
	so idk quite how to resolve this
	
	TODO: figure out how to allow for easy binding of new targets using code
	(may have to wait until I can get the Markers to snap and position themselves semi-automatically?)






=> Constraint Package
	Need to figure out how this matches up with the old Edge Group system
	this is basically the same thing, with a name that is arguably way worse.
	("Package" is a horribly generic name)
	
	like the Edge Group, probably need to store the visualization here as well.
	
	Holds the cache data for a constraint pair, which is critical to knowing when a constraint should run
	
	
	Constraint packages are stored in a linear collection.
	At least for now.
	This may change, once I get a better grasp on how the graph topologies in this system function.



=> Serialization of Bound Constraints
	similar to entity serialization:
	
	
	bound constraints are
	(entity, entity, constraint object)
	
	replace entity with serialization entity ID
	replace constraint object with the UUID assigned to that object by the ResourceCollection
	
	
	
	(also need to serialize any state particular to a binding, which may or may not include the cache. haven't figured that one out yet)
	NOT saving the cache would force ALL constraints to re-run on load
	you might want this, so that you can just "turn it off and on again" in case of error
	but it would be better just to make better constraints, and have rollback to previous state in case of "emergency" exceptional flow
	
	
	
	
	note that the ResourceCollection that maps UUIDs => constraint objects
	is actually a one-to-one relation
	so it could be a two-way hash or something like that
	and still work
	
	for serialization you need to invert the stored hash,
	but it may be worth considering if there should always be a method of going both ways





Where is constraint data stored?
	
	Constraints are stored at the Document level,
	because Chipmunk already defines a type called 'constraint' with an associated collection
	and associated #add_constraint and #remove_constraint functions







- old notes on constraints

	some double relations are even
	the same relationship in both directions    (truly can be condensed into a double-headed arrow)
	but some pairs have uneven relationships
	like a parent and child, or student and teacher
	data goes back and forth, but not the same sort of data
---











optimizations?


cycles / circular dependencies
race conditions

	these things are important to prevent
	but the system will not actively prevent you from making graphs that have these properties
	
	the exact time when some data gets to it's final destination
	is a property of the graph topology.
	In some cases, the data may never reach it's intended final destination,
		because there has been some sort of clobbering due to graph topology.
	In others, you may have things flip between a couple different states, but never settle down.
	
	It's basically too hard at this point to completely prevent these problems.
	It's hard to see these problems in standard text-editor code,
	which is part of why I wanted to make this system.
	I hope that in the future, some graph-level systems can be ported down to text-code for efficient prevention of common mistakes.


need to be careful of cycles
need to be careful of livelock as well as deadlock
(basically, be aware and concerned about distributed programming types of problems)



















should probably traverse part of the graph, and only fire constraints in the subgraph that need to be fired, rather the looping over all constraints and attempting to fire each one once

that would be more complicated,
but perhaps more efficient

but you have to make sure that you don't attempt to fire too many constraints per tick
otherwise the system would not run in real-time

(though potentially you could fire the same constraint multiple times is one tick?)


really just want to make sure that this case works correctly:
	a bunch of objects are instance of a prefab.
	the prefab is called A
	the instances are called X, Y, and Z
	
	when A is altered, X, Y, and Z should be changed
	and vice versa: when X, Y, or Z is altered, A should be changed
	(this second case causes a loop, where the new changes are systemically propagated to siblings)
	
	need to make sure this
		1) doesn't loop indefinitely     (would freeze the program)
		2) allows for seamless interactive updates that are not off-by-one frame







potentially, you need to have a limit to the number of constraints to evaluate per frame,
and then pass the job onto the the next frame if you exceed that limit
(similar to the dynamic-number-of-fixed-steps approach to physics simulation)
(would likewise have similar degradation characteristics as that physics approach)















can perform static analysis of graph to figure out how many edges you would have to traverse for changes to a particular property to propagate throughout the entire graph


should really implement this before system is developed too much further
would make it easy to see if it's worth it to only traverse changed paths,
instead of only updating each constraint pair once out of fear of going on forever
( also just makes for a generally nice debug tool )




those two strategies most likely have different degradation characteristics.
it's important to consider how systems will break,
not just how they will work under ideal / or best known circumstances






check all entities for...
	check all properties of the entity for...
		what happens if this property is changed?
		what constraints will need to be fired?
		
		how many edges will this data have to traverse before it finishes propagation?


( when you display this data, you probably want to hide the properties that do not need to be propagated )