module ThoughtTrace
	module Components


class Style < Component
	interface_name :style
	
	def initialize(style_system, pallet_name)
		# ??? does this component still require a name field? each Cascade already has a name
		
		
		# can have multiple modes
		# each style mode is described by one Cascade
		
		
		# I think if you want to specify a "parent style" that's part of the Cascade, not this obj
		
		# property reuse is probably more in how the objects are used, not in the raw architecture?
		
		
		
		
		
		
		
		# @active_mode = :default
		
		# mode = @active_mode
		
		# @modes = Hash.new
		
		# pallet = style_system.pallets[pallet_name]
		# cascade = ThoughtTrace::Style::Cascade.new pallet
		# @modes[mode] = cascade
		
		
		
		
		# style_name = "???"
		# @modes[mode].pallet[style_name] = ThoughtTrace::Style::StyleObject.new
		# @modes[mode].add style_name
		
		
		
		
		
		
		
		
		
		
		
		# @modes = {
		# 	:name => [cascade, style_name, style]
		# }
		
		
		
			# when you edit styles on an object
			# name of mode (NOT the same as the name of the style)
				# this name only needs to be unique within this component
				# (style components used for similar things will invariably have similar mode names)
			# cascade - CSS-like style hierarchy
			# style_name - the name of the "primary" style generated by this object in this mode
				# this name needs to be unique among all Style names in the StyleSystem
			# style - the style object associated with that name (linked here for convenience)
			
			
			# you should edit the "primary" style in the current mode
			# (maybe specify the mode? idk, definitely the "primary" style object, though)
			
			
			# things to put in the cascade include:
			# + "parent" styles from objects higher up in the structural hierarchy of the space
			# + styles from other modes of the same object
			# + styles from other objects, due to relative constraints (hair color matches shoes)
		
		
		
		
		@cascades = Hash.new
		
		
		pallet = style_system.pallets[pallet_name]
		
		
		style = ThoughtTrace::Style::StyleObject.new
		style_id = pallet.add style
		
		
		cascade = ThoughtTrace::Style::Cascade.new pallet
		cascade.add style_id
		@cascades[@current] = cascade
		
		
		@cascades[@current].primary_id
		
		
		
		# cascade order:
		# first element in the list should be the "primary" style
		# "primary" style should have the highest priority
		
		
		
		
		
	
		
		# NOTE: potential memory leak where StyleObject is empty (applies no visible change), persists outside of the StyleSystem (will not be serialized, which is good because it does nothing) but is still not being GCed (it's still "cached" in some style Component or something)
		
		
		
		
		# shouldn't need to serialize the StyleObjects from the Entity Component side
		# as they will all be serialized from the StyleSystem
		# (man these things all need new names)
		
		
		
		
		
		# NOTE: caching the style name makes it rather easy to get the wrong name for the Style, as names can change in the StyleSystem at any time. I think the "sensible" solution is to update the name often, but I'm not quite sure how.
			# (linking directly to the data, irrespective of "name" is good, but what about when you need a name, for user readability purposes?)
			# you want the name to be changeable at will, because it's only use is as a user ID
			# rather than a program-level ID
			# but how is that actually implemented?
			
			# note that the @pallets hash in StyleSystem needs to be inverted during dump / load
			# maybe the "inverted" step needs to be flipped?
			# like, normally you would store what would be seen as the "inverted" hash from the current perspective
			# (it may be better to map items => names, rather than names => items is what I mean)
			
			
			
			# you actually need the name => item path pretty often though
			# when you create a new component, you need to specify the pallet to use by name
				# is that itself an issue?
	end
	
	
	
	# Current thoughts: should probably ensure that the "primary" style always has the highest priority in the Cascade for this Component, so that changes to style through the Component will always results in visual changes.
	
	
	# Read properties through the Cascade
	def [](property)
		# foo = @properties[@mode][property]
		
		
		cascade, style_name, style = @modes[@current]
		foo = cascade[property]
		
		if foo.nil?
			mode = @current
			name = style_name
			warn "Warning: Property :#{property} not defined for :#{mode} mode of style #{name}"
		end
		
		return foo
	end
	
	# Set properties by modifying the "primary" style for the current mode
	def []=(property, value)
		cascade, style_name, style = @modes[@current]
		style[property] = value
	end
	
	
	# return the "primary" style for the current mode
	def primary_style
		@cascades[@current].primary_id
	end
	
	
	
	
	
	
	
	
	def change_style(style)
		# if the name currently exists, switch to that style instead
		# if the name does not exist, change the name of the current style
		# (this changing only modifies the "primary" style in the active mode)
	end
	
	
	def rename_style(new_name)
		cascade, style_name, style = @modes[@current]
		
		pallet = cascade.pallet
		pallet.delete style_name
		pallet[new_name] = style
	end
	
	# use some other Entity's cascade
	def link(other)
		cascade, style_name, style = @modes[@current]
		
		cascade = other.cascade # THIS IS PROBOBLY NOT RIGHT
		
		@modes[@current] = [cascade, style_name, style]
	end
	
	
	# Place argument in the Cascade with priority one lower than the "primary" style
	def inherit(parent)
		
	end
	
	
	
	
	
	
	
	
	def update
		
	end
	
	def draw(z=0)
		
	end
	
	
	
	
	def mode=(new_mode)
		@properties[new_mode] ||= Hash.new
		
		@mode = new_mode
	end
	
	def mode
		return @mode
	end
	
	
	
	
	
	# Edit one style mode (not necessarily the active mode)
	# Protects against forgetting to switch back after temporarily switching modes to make an edit
	def edit(mode=@mode)
		# want to use the methods to get / set mode, rather than instance variables
		# kinda weird relative to standard ruby style, but it needs to happen
		# so that the hashes can be initialized correctly,
		# without having to repeat the init code all over the place
		old_mode = self.mode
			self.mode = mode
			
			self.tap do |mode_handle|
				yield mode_handle
			end
		self.mode = old_mode
	end
end



end
end