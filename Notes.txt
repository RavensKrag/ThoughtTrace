Need to figure out how to get two bits of text with different sizes to line up.
	It's not as simple as just lining up the beginnings of the two lines, because the spacing between the start of the line and the start of the string is different.  It may depend on the first character.
	
	But even if it does, the first characters of the two strings being identical doesn't fix the problem.


NOTE: There's a bit of a problem with Gosu::TextInput.  You can't type anything that requires SHIFT
	You can type capitals, but no special characters


TODO: Refactor the way that paint box is used by Text.  Too easy to forget to set the paint box and get all sorts of weird errors.
I would like to set the paint box in one place, but it seems like many errors could occur with the current framework.  

NOTE: Implement reformatting text (grabbing a section and creating a new object out of it) before reflowing blocks.  The reformatting feature will be helpful for prototyping auto-reflow.  Should probably have grouping as well.

text reflow --dependent on--> [reformatting, grouping]


NOTE: z-order for mouse over highlight is kinda messed up. The hitbox should always be displayed on mouseover, but if there is an active element, the active element's hitbox will block out smaller hitboxes in the area.


TODO: Clarify difference between #release and #deactivate on objects
	I think it was intended to be that both parts are needed for a click selection, but only #deactivate would be called for multi-select or similar?


Text size for new text objects should be the same as the previous object
	or for objects that were spawned out of other objects, the parent of the spawn


Input caret should stop flashing when the program loses focus
	This is common to all other applications, imo
	
	It's kinda annoying to lose your place because the caret went away though
	so there needs to be a solution to that




Click and drag in empty space should generate a text box
	more natural than typing something, and then spacing it into a box later
	you naturally create a box in your mind when you want to write something on a section of paper
	that's how you have an intuitive sense of where to stop writing and start a new line
	
	control of box guiding text flow and editing of text should be separate buttons, so that you can bounce between them with fluidity


ping feature for collaboration
	hold down button to charge
	cursor begins to gather light
	releasing quickly
		light leaves rapidly, emitting bell tone
		display ripples radiating from cursor
	hold + drag
		(draw path)
		cursor leaks glowing fluid
		glow fades over time

listify ability
	when a group of items is selected, offer option to listify
	
	take all items at approximately the same size
		average the size
		assign size to all
		create a style for easy group editing later (may want to disable?)
	all items at about the same size are assumed to be at the same level of the list
		(may want to do it by indentation instead / also)
	
	If there is no heading
		create heading
		select heading, ready for editing

mouse pick priority
	when selecting objects visually from hierarchy,
	hierarchy precedence should overtake visual structure
	
	when visually selecting objects that are grouped into a hierarchy,
	sort preference based on hierarchy, then visual structure
	
	when selecting objects visually from hierarchy,
	hierarchy should have priority over visual structure

advanced styles applied by regex patterns
	(could use other fancy method (lexer or w/e) to allow pattern matching)
	easily apply styles such as "select things in parentheses, make them small and washed out"
	
would be nice to not have to override #initialize for mouse events, as they syntax would be cleaner
	would be some weird, weird magic though







really don't need to pass the @selection variable to each callback.  each event has it's own @selection variable, so you could just use that
	or maybe the way values are passed to callbacks should be changed, so this var no longer exists?
	
	the reason why it passes the var into the callback, is that the callback used to be a block
	it didn't make sense for the user to understand the internals when the interface was built to abstract the internals away
	the current interface is inheritance, which requires an understanding of the things you inherit from
	
	
	
	the function callback-style interface is nice though,
	as it allows for delegation to other mouse event handlers
	this allows for an event handler to build on many different behaviors though delegation/composition




consider renaming MouseEvent#add_to(mouse)
	it's not really about adding data to the mouse,
	it's about copying data over from the mouse into a specific event




BUG: MoveText and CutText are triggering at the same time
	seems like really only one selection should be made per frame
													or, per one button press
BUG: Box select triggers while trying to highlight text
	may want to trigger it only when dragging around objects, rather than on top of them?


TODO: need to make sure highlight range goes from low to high. not guaranteed, so could get weird if drag happens right-to-left



should really copy from text input buffer to Text string
before performing any operations on the string
	otherwise, you'd have to perform the operations on the active string basis
	when active, this basis would be the string buffer,
	when non-active, this basis would be the stored string
	
	already using a state machine to track the "active" status, so this isn't that hard
	
	but, can't guaranteed the buffer can be operated on in the exact same way a standard string
	




if method is defined in any state_machine state
objects of that class will respond? to the method
regardless of what state the object is in





binding
	separate events from input parsing system
programmatic control
	when events and user inputs are separated,
	the same events used by end users can be fired programatically

collision
	need to be able to detect collisions between events bound to inputs
cancel
	currently, certain inputs must cancel others
	selection queries must cancel others
		highlight should add highlighted entries to space, so that move triggers on them instead
		- should not be able to move the highlights themseleves though,



composition
	want to be able to create events composed of other events
	
	useful for hitting Enter to start a new line of text
		* deselect active element
		* create new text
		+ move new text element into next line position





binding actions currently keys the binding based on the action object
this means that multiple actions of the same type can be bound, if necessary
however, the interface to get actions out of the action group keys by class,
so only one object can be stored per class

	should make this behavior consistent
	should probably just store based on a name, or something
		
		but if the name is generated based on the name of the class,
		this is the same as just using the class object
		
		would have to give each instance it's own key
		would basically just be using a hash straight up then
		which would get a bit tedious
		
		but is the tedium really an issue?
		eventually, it's going to all be managed by a program anyway
		the bindings will never be edited in a text file after a while
		it will all be done with the graphical tool
		
		
		not really sure that you need more than one instance of each class per one input manager
		the point of using instances of a class is so you can have multiple input managers
		
			this is useful for mulitplayer
			this may be useful for different input modes


NOTE: Actions currently bound to mouse inputs using a string representation of the class name.  Assuming also that Action#name is defined, and will return this value.  This method has yet to be set up.




NOTE: Current implementation of action does not store parameter to #press automatically.  The user is responsible for storing it, if he wants to keep it around.  Which is kinda weird, because it's assumed that one value should come into the system, and then be used by three different steps.


TODO: Figure out better way to create Actions with no #press argument
current method sending nil through super() is kind clunky, as that nil travels through the pipeline