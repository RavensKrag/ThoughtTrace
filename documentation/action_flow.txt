Actions provide a human interface to firing mutations of objects specified through code.



Actions
	house code needed to execute procedures using a combination of button and mouse inputs

Components
	namespaces for core functionality (ex, physics)

Entity#methods
	manipulate data from anywhere in the Entity (including Components)


Actions cause change by firing entity#methods
precise method sequence is held in the nested Memento class for each Entity subclass
this compartmentalization allows for easy undo / redo
as well as the potential for extracting method sequences for macros etc
	ruby methods can be treated as objects,
	which can be handled much like procs.
	src: http://viget.com/extend/convert-ruby-method-to-lambda






input manager                  -  oversees general flow for all forms of input

mouse                          -  provide access to mouse position (as vector)
button parser                  -  parse raw button up/down sequence to launch button events
button event                   -  abstracted digital input control with push-hold-release structure
mouse action controller        -  links mouse to action flow controller
action flow controller         -  given a point, figure out which actions to fire on what
click and drag controller      -  controls the click and drag twin-linked phase of action flow



action                         -  uses buttons and mouse inputs to fire methods.
                                  returns memento for undo/redo

entity                         -  an object in the space
                                  contains Components
                                  contains methods for manipulation
                                  namespaces actions (actions resolved by following hierarchy)





# Actions are always stored like this:
# inside of an 'Actions' module under the class they control

module ThoughtTrace
	class Entity
		module Actions


class Action
	#setup(point) => nil
	#update(point) => @original, current
	#cleanup(point) => nil
	
	
	class Memento
	end
end



end
end
end






+ button inputs are abstracted, and button events are fired

+ mouse is used by action flow controller to figure out where to poll the space for an Entity

+ actions are selected by the action flow controller based on the type of Entity extracted

+ click and drag controller stores one action for the click phase, and one for the drag phase

+ click actions are canceled automatically by the flow controller if the mouse moves after button press, so a single input event can have both a click and a drag input mapped to it

