current known things:
	
	constraint packages stored in linear collection
	pairs are updated though Packages
	each Package is updated once per frame
	
	each Constraint object can be used in multiple Pairs (thus multiple Packages)
	but that doesn't matter because they don't retain multi-pair state
	
	














how fast do changes propagate through the graph?

	should move at least across one edge per frame,
	but it's not super clear when things will get to their destination
	(it's rather like a distributed programming problem, in that way)
	
	there's no point in trying to make it
	so changes can propagate across the entire graph in one tick:
		that would just make it harder for the system to function in real time
		for large graphs
	
	
	
	(NOTE: this is not totally accurate. you just have to make sure you don't traverse too many long paths. ("long" being relative to N, where N is the number of active constraint pairs). However, the current implementation tries to keep things simple by only updating each constraint pair once per tick. This ensures no loops or combinatorial explosion, but may cause other errors.)






note that changes won't always propagate the same way
- dependent on graph topology and update order






multiple types of changes can propagate within the same tick,
but not all data will propagate to it's final destination in one tick.
sometimes, the system will need many ticks for data to traverse certain paths.
hopefully though, no data gets stuck in a node, unable to leave the edge, or anything like that
(current system does not prevent against deadlock / livelock)
(exercise caution when designing graph topologies)

I feel like data should probably at least leave it's original source within one tick in most situations...




***
	you could maybe reduce the likelyhood of issues like clobbering, livelock / deadlock, etc
	by looking at the entire path through the graph, from the changed node to the 'leaves',
	and propagating that change all at once.

	you don't have to examine all constraints,
	just the ones of the same type.


	idk, that might actually be harder.
	I'll have to try it out though, because it might solve some problems.
	(but it might just cause a bunch of others)
---

how do you create that and traverse it?
the core graph is user-generated
but then the sub-graph is also a graph
and it may have some cycles in it
you need to prevent execution of a multiple looping paths through the graph in one tick



maybe that's wrong, and it should be like an "everyone pass one to your right" per tick thing
meaning, that sometimes the simulation will take more ticks to propagate changes than others

^ note that this means any sort of 'linear-ization' of the graph will have to check for cycles


but the standard technique being applied going forward,
does not need to check for cycles
because it will only evaluate each edge once per tick







really only want to update each edge once per tick
	
	this means that some changes will take many ticks
	to propagate all the way to their destination,
	but it ensures that you will never get stuck
	in a situation where you have to traverse an
	entire loop of the graph
		(or multiple iterations of this loop, even)
	in one tick
	
	games have circular flow.
	if you want a 'loop'
	you often want one tick of the loop executed per game tick
	you very rarely want to use a straight 'while' loop in a game
	
	this system is a similar sort of thing
	
	
	note that 'one edge' in this case means
	one pair-wise relationship between two Entity objects
	related by one constraint.
	Thus, the same pair of Entities can be connected by multiple edges,
	even in the same direction,
	and having all of those update in the same frame is totally fine.
	
	But you don't want the same constraint firing
	between two Entity objects multiple times in one frame
	
	
	
	because that has the possibility of creating cycles,
	and that's really bad
	
	
	but note that this is different that firing a Constraint object once per tick,
	because one Constraint object can be used in multiple Pairs

	





















will the system systemically stop looping? or does it need a check?

(((  inspired by Massive Chalice's exploding alchemist armor,
     which chains, but does not loop  )))
------------------------------------------------------------------------------

wait no, it should systemically stop looping
like, it already does without having to do this

it will take a couple of iterations sometimes,
but the system should be able to realize that no values are changing,
and thus will "sleep" the constraints
and not update them
because they do not need to run
because values are not changing
and thus there are no values to propagate






I think the constraint system assumes that you only change one value in the graph per tick
then one entire tick can be dedicated to propagating that one change





but when you update, you want to use a dependency graph, not just a list
	update constraints based on dependency graph, or just a list?





